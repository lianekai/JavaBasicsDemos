学习多线程

程序一段静态代码，应用执行的蓝本。进程是程序的一次动态执行过程
java应用程序都是从主类的ma4in方法开始执行。JVM加载到代码，发现main方法后，启动一个线程---主线程，负责执行main方法，执行中可以继续创建其他线程，如没有创建其他线程，
执行完main方法的最后一个语句，JVM就会结束应用程序。如果创建了其他线程，JVM就要在线程之间轮流切换，保证都有机会使用CPU资源。运行完所有线程才结束应用程序。

线程的生命周期：
    新建：被Thread类或者其子类的对象声明并创建，就赋予了内存空间以及其他资源
    运行：创建后即有运行条件，轮到他享用CPU资源，JVM的使用权就被赋予该线程。线程创建后仅占内存，调用start()方法后被JVM知道该线程在等待资源，JVM交CPU使用权使
          若由Thread子类创建，该类中run()方法立即执行，必须重写父类run（）方法，没有结束run（）方法，不能继续调用start方法，否则发生异常。
    中断：4种原因--被JVM让出CPU，占用时间长了或轮到其他线程使用CPU了
                --使用CPU时，调用了sleep（int millsecond）方法，之后会进入线程休眠，让出CPU，重新进入线程队列等待下次CPU资源使用
                --使用CPU时，执行wait()方法，线程进入等待状态，线程等待不会进入线程队列，要被其他线程调用notify（）方法通知，使其进去线程等待队列。
                --使用CPU时，执行某个操作浸入阻塞状态，如执行读写操作引起阻塞，进入阻塞状态的线程不能进入等待队列，消除阻塞原因后方可重新进入等待队列等待。
    死亡：处于死亡的线程无法继续运行，死亡原因：2个
                                               --正常线程已经完成其全部工作，即实行完run（）方法全部语句
                                               --线程被提前强制终止，即强制将run()方法结束。
          线程死亡后释放实体，释放分配给线程的内存 。

线程调度及优先级：
    处于就绪态线程首先进入就绪队列等待jvm分配CPU的使用，虚拟机（JVM）的线程调度器管理线程，调度器将线程优先级分为1至10级，用Thread的类常量表示：
    Thread.MIN_PRIORITY和Thread.MAX_PRIORITY  ,没指明优先级，每个线程优先级都为5：Thread.NORM_PRIORITY。线程优先级通过setPriority调整，getPriority返回线程优先级。



多进程：一个时间段上同时运行多个程序 ，这些程序将进行资源的轮流抢占，所以一个时间段上会有多个程序依次执行
 *  线程：进程基础上划分的更小的程序单元，线程在进程的基础上创建并且使用，线程依赖于进程
 *  进程-》操作系统上的划分              线程-》进程上划分
 *
 *  java实现多线程，需要一个专门的线程主体类进行线程的执行任务的定义，实现特定的接口或继承特定的父类完成
 *
 *  1.继承Thread 实现多线程
 *  	继承：java.lang.Thread类 复写Thread类的run方法
 *  	多线程要执行的功能都应该在run方法中进行定义，run方法不能直接被调用，要启动多线程必须使用start()方法完成
 *  	每个线程类的对象只能被启动一次，即start()一次，否则抛出异常
 *  	只要定义了多线程，多线程的启动就只能由Thread类的start()方法启动
 *  2.基于Runnable接口实现多线程（java.lang.Runnable）